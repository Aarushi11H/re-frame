// Compiled by ClojureScript 1.10.597
goog.provide("re_frame.loggers");
/**
 * Holds the current set of logging functions.
 * By default, re-frame uses the functions provided by js/console.
 * Use `set-loggers!` to change these defaults
 *   
 */
re_frame.loggers.loggers = cljs.core.atom.call(null,new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,"log","log",(-1595516004)),console.log.bind(console),new cljs.core.Keyword(null,"warn","warn",(-436710552)),console.warn.bind(console),new cljs.core.Keyword(null,"error","error",(-978969032)),console.error.bind(console),new cljs.core.Keyword(null,"debug","debug",(-1608172596)),console.debug.bind(console),new cljs.core.Keyword(null,"group","group",(582596132)),(cljs.core.truth_(console.group)?console.group.bind(console):console.log.bind(console)),new cljs.core.Keyword(null,"groupEnd","groupEnd",(-337721382)),(cljs.core.truth_(console.groupEnd)?console.groupEnd.bind(console):(function (){
return cljs.core.List.EMPTY;
}))], null));
re_frame.loggers.console = (function re_frame$loggers$console(var_args){
var args__12462__auto__ = [];
var len__12445__auto___648 = arguments.length;
var i__12446__auto___649 = (0);
while(true){
if((i__12446__auto___649 < len__12445__auto___648)){
args__12462__auto__.push((arguments[i__12446__auto___649]));

var G__650 = (i__12446__auto___649 + (1));
i__12446__auto___649 = G__650;
continue;
} else {
}
break;
}

var argseq__12463__auto__ = ((((1) < args__12462__auto__.length))?(new cljs.core.IndexedSeq(args__12462__auto__.slice((1)),(0),null)):null);
return re_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__12463__auto__);
});

(re_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic = (function (level,args){
if(cljs.core.contains_QMARK_.call(null,cljs.core.deref.call(null,re_frame.loggers.loggers),level)){
} else {
throw (new Error(["Assert failed: ",["re-frame: log called with unknown level: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(level)].join(''),"\n","(contains? (clojure.core/deref loggers) level)"].join('')));
}

return cljs.core.apply.call(null,level.call(null,cljs.core.deref.call(null,re_frame.loggers.loggers)),args);
}));

(re_frame.loggers.console.cljs$lang$maxFixedArity = (1));

/** @this {Function} */
(re_frame.loggers.console.cljs$lang$applyTo = (function (seq646){
var G__647 = cljs.core.first.call(null,seq646);
var seq646__$1 = cljs.core.next.call(null,seq646);
var self__12420__auto__ = this;
return self__12420__auto__.cljs$core$IFn$_invoke$arity$variadic(G__647,seq646__$1);
}));

/**
 * Change the set (or a subset) of logging functions used by re-frame.
 *   `new-loggers` should be a map with the same keys as `loggers` (above)
 */
re_frame.loggers.set_loggers_BANG_ = (function re_frame$loggers$set_loggers_BANG_(new_loggers){
if(cljs.core.empty_QMARK_.call(null,clojure.set.difference.call(null,cljs.core.set.call(null,cljs.core.keys.call(null,new_loggers)),cljs.core.set.call(null,cljs.core.keys.call(null,cljs.core.deref.call(null,re_frame.loggers.loggers)))))){
} else {
throw (new Error(["Assert failed: ","Unknown keys in new-loggers","\n","(empty? (difference (set (keys new-loggers)) (-> (clojure.core/deref loggers) keys set)))"].join('')));
}

return cljs.core.swap_BANG_.call(null,re_frame.loggers.loggers,cljs.core.merge,new_loggers);
});
/**
 * Get the current logging functions used by re-frame.
 */
re_frame.loggers.get_loggers = (function re_frame$loggers$get_loggers(){
return cljs.core.deref.call(null,re_frame.loggers.loggers);
});

//# sourceURL=re_frame/loggers.js
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVfZnJhbWUvbG9nZ2Vycy5qcyIsInNvdXJjZXMiOlsibG9nZ2Vycy5jbGpzIl0sImxpbmVDb3VudCI6NzAsIm1hcHBpbmdzIjoiO0FBYUE7Ozs7OztBQUFlQSwyQkFLYix5QkFBQSwyQ0FBQSxnRkFBQSxrRkFBQSxxRkFBQSxzRkFBQSxnSkFBQSxqaUJBQUNDLDBIQUEwQixBQUFDQyxpQkFBc0JDLGdFQUN2QixBQUFDQyxrQkFBc0JELGtFQUN2QixBQUFDRSxtQkFBc0JGLG1FQUN2QixBQUFDRyxtQkFBc0JILGlFQUN2QixrQkFBSSxBQUFTQSxlQUNYLEFBQUNJLG1CQUFzQkosU0FDdkIsQUFBQ0QsaUJBQXNCQyx5RUFDekIsbUVBQUEsakRBQUksQUFBWUEsa0JBQ2QsQUFBQ0ssc0JBQXlCTDtBQUQ1QixBQUFBOztBQVc3QixBQUFBLDJCQUFBLG1DQUFBTSw5REFBTUs7QUFBTixBQUFBLElBQUFKLHNCQUFBO0FBQUEsQUFBQSxJQUFBQyx5QkFBQSxBQUFBO0FBQUEsQUFBQSxJQUFBQyx1QkFBQTs7QUFBQSxBQUFBLEdBQUEsQ0FBQUEsdUJBQUFEO0FBQUEsQUFBQSxBQUFBRCx5QkFBQSxDQUFBLFVBQUFFOztBQUFBLGFBQUEsQ0FBQUEsdUJBQUE7Ozs7QUFBQTs7OztBQUFBLElBQUFDLHdCQUFBLEVBQUEsQ0FBQSxNQUFBLEFBQUFILDZCQUFBLEFBQUEsMEJBQUEsQUFBQUEsMEJBQUEsS0FBQSxJQUFBLE9BQUEsL0RBOGpHc0R5QjtBQTlqR3RELEFBQUEsT0FBQXJCLDhEQUFBLENBQUEsVUFBQSxNQUFBRDs7O0FBQUEsQUFBQSxDQUFBLGdFQUFBLGhFQUFNQywyRUFDSEksTUFBUUM7QUFEWCxBQUVFLEdBQVEsb0NBQUEsQUFBQUUscENBQUNDLDhEQUFXdEIsMEJBQVFrQjtBQUE1QjtBQUFBLEFBQUEsTUFBQSxLQUFBRSxNQUFBLENBQUEsNEhBQUEsS0FBQSwvR0FBbUMsQ0FBQSx3RkFBaURGOzs7QUFDcEYsT0FBQ0ssMEJBQU0sZ0JBQUEsQUFBQUYsaEJBQUNILDBDQUFPbEIsMkJBQVNtQjs7O0FBSDFCLENBQUEsbURBQUEsbkRBQU1MOztBQUFOO0FBQUEsQ0FBQSw2Q0FBQSxXQUFBQyx4REFBTUQ7QUFBTixBQUFBLElBQUFFLFNBQUEsMEJBQUFELDFCQSsvRmdEa0I7SUEvL0ZoRGxCLGFBQUEseUJBQUFBLHpCQWdnR2tEbUI7QUFoZ0dsRCxBQUFBLElBQUFqQixzQkFBQTtBQUFBLEFBQUEsT0FBQUEseURBQUFELE9BQUFEOzs7QUFBQSxBQU1BOzs7O3FDQUFBLHJDQUFNUyxrRkFHSEM7QUFISCxBQUlFLEdBQVMsQUFBQ0MsaUNBQU8sQUFBQ0MsaUNBQVcsQUFBQ0Msd0JBQUksQUFBQ0MseUJBQUtKLGNBQWMsd0JBQUEseUJBQUEsQUFBQUosMEJBQUtyQixuREFBUTZCLHhCQUFLRDtBQUF4RTtBQUFBLEFBQUEsTUFBQSxLQUFBUixNQUFBLENBQUEsa0JBQUEsOEJBQUEsS0FBQTs7O0FBQ0EsT0FBQ1UsK0JBQU05Qix5QkFBUStCLGdCQUFNTjs7QUFFdkI7OzsrQkFBQSwvQkFBTU87QUFBTixBQUFBLE9BQUFYLDBCQUdHckIiLCJuYW1lcyI6WyJyZS1mcmFtZS5sb2dnZXJzL2xvZ2dlcnMiLCJjbGpzLmNvcmUvYXRvbSIsImpzL2NvbnNvbGUubG9nLmJpbmQiLCJqcy9jb25zb2xlIiwianMvY29uc29sZS53YXJuLmJpbmQiLCJqcy9jb25zb2xlLmVycm9yLmJpbmQiLCJqcy9jb25zb2xlLmRlYnVnLmJpbmQiLCJqcy9jb25zb2xlLmdyb3VwLmJpbmQiLCJqcy9jb25zb2xlLmdyb3VwRW5kLmJpbmQiLCJ2YXJfYXJncyIsImFyZ3NfXzEyNDYyX19hdXRvX18iLCJsZW5fXzEyNDQ1X19hdXRvX18iLCJpX18xMjQ0Nl9fYXV0b19fIiwiYXJnc2VxX18xMjQ2M19fYXV0b19fIiwicmUtZnJhbWUubG9nZ2Vycy9jb25zb2xlIiwic2VxNjQ2IiwiR19fNjQ3Iiwic2VsZl9fMTI0MjBfX2F1dG9fXyIsImxldmVsIiwiYXJncyIsImpzL0Vycm9yIiwiY2xqcy5jb3JlL2RlcmVmIiwiY2xqcy5jb3JlL2NvbnRhaW5zPyIsImNsanMuY29yZS9hcHBseSIsInJlLWZyYW1lLmxvZ2dlcnMvc2V0LWxvZ2dlcnMhIiwibmV3LWxvZ2dlcnMiLCJjbGpzLmNvcmUvZW1wdHk/IiwiY2xvanVyZS5zZXQvZGlmZmVyZW5jZSIsImNsanMuY29yZS9zZXQiLCJjbGpzLmNvcmUva2V5cyIsImNsanMuY29yZS9zd2FwISIsImNsanMuY29yZS9tZXJnZSIsInJlLWZyYW1lLmxvZ2dlcnMvZ2V0LWxvZ2dlcnMiLCJjbGpzLmNvcmUvZmlyc3QiLCJjbGpzLmNvcmUvbmV4dCIsImNsanMuY29yZS9JbmRleGVkU2VxIl0sInNvdXJjZXNDb250ZW50IjpbIihucyByZS1mcmFtZS5sb2dnZXJzXG4gICg6cmVxdWlyZVxuICAgW2Nsb2p1cmUuc2V0IDpyZWZlciBbZGlmZmVyZW5jZV1dXG4gICAjP0AoOmNsaiBbW2Nsb2p1cmUuc3RyaW5nIDphcyBzdHJdXG4gICAgICAgICAgICAgW2Nsb2p1cmUudG9vbHMubG9nZ2luZyA6YXMgbG9nXV0pKSlcblxuIz8oOmNsaiAoZGVmbiBsb2cgW2xldmVsICYgYXJnc11cbiAgICAgICAgICAobG9nL2xvZyBsZXZlbCAoaWYgKD0gMSAoY291bnQgYXJncykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoZmlyc3QgYXJncylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChzdHIvam9pbiBcIiBcIiBhcmdzKSkpKSlcblxuXG47OyBYWFggc2hvdWxkIGxvZ2dlcnMgYmUgcHV0IGluIHRoZSByZWdpc3RyYXIgPz9cbihkZWYgXjpwcml2YXRlIGxvZ2dlcnNcbiAgXCJIb2xkcyB0aGUgY3VycmVudCBzZXQgb2YgbG9nZ2luZyBmdW5jdGlvbnMuXG4gICBCeSBkZWZhdWx0LCByZS1mcmFtZSB1c2VzIHRoZSBmdW5jdGlvbnMgcHJvdmlkZWQgYnkganMvY29uc29sZS5cbiAgIFVzZSBgc2V0LWxvZ2dlcnMhYCB0byBjaGFuZ2UgdGhlc2UgZGVmYXVsdHNcbiAgXCJcbiAgKGF0b20gIz8oOmNsanMgezpsb2cgICAgICAgKGpzL2NvbnNvbGUubG9nLmJpbmQgICBqcy9jb25zb2xlKVxuICAgICAgICAgICAgICAgICAgOndhcm4gICAgICAoanMvY29uc29sZS53YXJuLmJpbmQgIGpzL2NvbnNvbGUpXG4gICAgICAgICAgICAgICAgICA6ZXJyb3IgICAgIChqcy9jb25zb2xlLmVycm9yLmJpbmQganMvY29uc29sZSlcbiAgICAgICAgICAgICAgICAgIDpkZWJ1ZyAgICAgKGpzL2NvbnNvbGUuZGVidWcuYmluZCBqcy9jb25zb2xlKVxuICAgICAgICAgICAgICAgICAgOmdyb3VwICAgICAoaWYgKC4tZ3JvdXAganMvY29uc29sZSkgICAgICAgICA7OyBjb25zb2xlLmdyb3VwIGRvZXMgbm90IGV4aXN0ICA8IElFIDExXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGpzL2NvbnNvbGUuZ3JvdXAuYmluZCBqcy9jb25zb2xlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChqcy9jb25zb2xlLmxvZy5iaW5kICAganMvY29uc29sZSkpXG4gICAgICAgICAgICAgICAgICA6Z3JvdXBFbmQgIChpZiAoLi1ncm91cEVuZCBqcy9jb25zb2xlKSAgICAgICAgOzsgY29uc29sZS5ncm91cEVuZCBkb2VzIG5vdCBleGlzdCAgPCBJRSAxMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChqcy9jb25zb2xlLmdyb3VwRW5kLmJpbmQganMvY29uc29sZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjKCkpfSlcbiAgICAgICAgOzsgY2xvanVyZSB2ZXJzaW9uc1xuICAgICAgICAjPyg6Y2xqIHs6bG9nICAgICAgKHBhcnRpYWwgbG9nIDppbmZvKVxuICAgICAgICAgICAgICAgICA6d2FybiAgICAgKHBhcnRpYWwgbG9nIDp3YXJuKVxuICAgICAgICAgICAgICAgICA6ZXJyb3IgICAgKHBhcnRpYWwgbG9nIDplcnJvcilcbiAgICAgICAgICAgICAgICAgOmRlYnVnICAgIChwYXJ0aWFsIGxvZyA6ZGVidWcpXG4gICAgICAgICAgICAgICAgIDpncm91cCAgICAocGFydGlhbCBsb2cgOmluZm8pXG4gICAgICAgICAgICAgICAgIDpncm91cEVuZCAgIygpfSkpKVxuXG4oZGVmbiBjb25zb2xlXG4gIFtsZXZlbCAmIGFyZ3NdXG4gIChhc3NlcnQgKGNvbnRhaW5zPyBAbG9nZ2VycyBsZXZlbCkgKHN0ciBcInJlLWZyYW1lOiBsb2cgY2FsbGVkIHdpdGggdW5rbm93biBsZXZlbDogXCIgbGV2ZWwpKVxuICAoYXBwbHkgKGxldmVsIEBsb2dnZXJzKSBhcmdzKSlcblxuXG4oZGVmbiBzZXQtbG9nZ2VycyFcbiAgXCJDaGFuZ2UgdGhlIHNldCAob3IgYSBzdWJzZXQpIG9mIGxvZ2dpbmcgZnVuY3Rpb25zIHVzZWQgYnkgcmUtZnJhbWUuXG4gIGBuZXctbG9nZ2Vyc2Agc2hvdWxkIGJlIGEgbWFwIHdpdGggdGhlIHNhbWUga2V5cyBhcyBgbG9nZ2Vyc2AgKGFib3ZlKVwiXG4gIFtuZXctbG9nZ2Vyc11cbiAgKGFzc2VydCAgKGVtcHR5PyAoZGlmZmVyZW5jZSAoc2V0IChrZXlzIG5ldy1sb2dnZXJzKSkgKC0+IEBsb2dnZXJzIGtleXMgc2V0KSkpIFwiVW5rbm93biBrZXlzIGluIG5ldy1sb2dnZXJzXCIpXG4gIChzd2FwISBsb2dnZXJzIG1lcmdlIG5ldy1sb2dnZXJzKSlcblxuKGRlZm4gZ2V0LWxvZ2dlcnNcbiAgXCJHZXQgdGhlIGN1cnJlbnQgbG9nZ2luZyBmdW5jdGlvbnMgdXNlZCBieSByZS1mcmFtZS5cIlxuICBbXVxuICBAbG9nZ2VycylcbiJdfQ==