<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Builtin Effects</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" type="text/css" href="styles/codox-re-frame.css" /></head><body><div></div><div class="sidebar primary"><div></div><div></div><div></div><ul><li class="depth-1 "><a href="api-intro.html"><div class="inner"><span>Overview</span></div></a></li><li class="depth-1  current"><a href="api-builtin-effects.html"><div class="inner"><span>Builtin Effects</span></div></a></li></ul><div></div><ul><li class="depth-1 "><a href="re-frame.core.html"><div class="inner"><span>re-frame.core</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><div class="sidebar secondary" style="width: 218px; left: 161px;">
    <h3 class="current">
        <a href="api-builtin-effects.html#top">
            <span class="inner">Builtin Effects</span>
        </a>
    </h3>
    <ul>
        <li class="depth-1">
            <a href="api-builtin-effects.html#db">
                <div class="inner">
                    <span>:db</span>
                </div>
            </a>
        </li>    
        <li class="depth-1">
            <a href="api-builtin-effects.html#fx">
                <div class="inner">
                    <span>:fx</span>
                </div>
            </a>
        </li>
        <li class="depth-1">
            <a href="api-builtin-effects.html#dispatch">
                <div class="inner">
                    <span>:dispatch</span>
                </div>
            </a>
        </li>
        <li class="depth-1">
            <a href="api-builtin-effects.html#dispatch-later">
                <div class="inner">
                    <span>:dispatch-later</span>
                </div>
            </a>
        </li>
        <li class="depth-1">
            <a href="api-builtin-effects.html#deregister-event-handler">
                <div class="inner">
                    <span>:deregister-event-handler</span>
                </div>
            </a>
        </li>
        <li class="depth-1">
            <a href="api-builtin-effects.html#dispatch-n">
                <div class="inner">
                    <span>:dispatch-n</span>
                </div>
            </a>
        </li>                            
    </ul>
</div>
<h1><a href="#builtin-effects" name="builtin-effects"></a>Builtin Effects</h1>
<p>In addition to the API provided in <code>re-frame.core</code>, re-frame supplies a small number of built-in effects which also contribute to the API.</p>
<h2><a href="#ordering" name="ordering"></a>Ordering</h2>
<p>An event handler (registered via <code>reg-event-fx</code>) can return a map containing many effects, but maps are unordered. So, in what order will re-frame action effects?</p>
<p>For example, if an event handler returned:</p>
<pre><code class="clj ">{:dispatch [:some-id]
 :http     {:method :GET  :url "http://somewhere.com/"}
 :db       new-db}
</code></pre>
<p>Will the <code>:dispatch</code> effect be actioned before <code>:http</code>, and what about <code>:db</code>?</p>
<p><strong><em>Prior to v1.1.0</em></strong>: re-frame provided no guarantees regarding ordering. It was an implementation detail on which you couldn’t rely.</p>
<p><strong><em>From v1.1.0 onwards</em></strong>, two things changed:</p>
<ul>
  <li>re-frame guarantees that the <code>:db</code> effect will be actioned first, if present. But there remains no guarantee for other effects.</li>
  <li>a new effect, called <code>:fx</code>, is added. It allows you to specify an ordered sequence of effects.</li>
</ul>
<p>With v1.1.0 <strong><em>best practice</em></strong> probably changed: an event handler should return only two effects <code>:db</code> and <code>:fx</code>. The <code>:db</code> effect will be actioned first, and then <code>:fx</code>, but within <code>:fx</code> effects will be actioned in the sequence provided. The true reason for this change is that it makes it easier to compose event handlers from a number of smaller functions, but it incidently also allowed more specificity around ordering. So that was a bonus. </p>
<p>So, the new approach encourages effects to be something like:</p>
<pre><code class="clj">{:db new-db 
 :fx [...]}   ;; &lt;-- optional, contains one effect after another
</code></pre>
<h2><a href="#db" name="db"></a><a name="db"></a> :db</h2>
<p><code>reset!</code> <code>app-db</code> to be a new value. </p>
<p>The associated <code>value</code> is expected to be a map. This is always actioned first, before any other effect.</p>
<p>usage:</p>
<pre><code class="clojure">{:db  {:key1 value1 key2 value2}}   
</code></pre>
<p>Real usage might look like this: </p>
<pre><code class="clojure">(reg-event-fx
  :token 
  (fn [{:keys [db]} event]
    {:db  (assoc db :some-key some-val)}))     ;; &lt;-- new value computed
</code></pre>
<h2><a href="#fx" name="fx"></a><a name="fx"></a> :fx</h2>
<p>An effect which actions other effects, sequentially. </p>
<p>Expects a value which is a sequence, typically a vector. Each element in the sequence represents one effect. Each element is a 2-tuple of (1) an effect id and (2) the payload of the effect (the value ultimately given to the registered effect handler as an argument). </p>
<p>For example:</p>
<pre><code class="clj">{:db  new-db 
 :fx  [[:dispatch   [:some-id]]
       [:http-xhrio {:method :GET  :url "http://somewhere.com/"}]
       (when (&gt; 2 3) [:some-effect-id  some-payload])]}
</code></pre>
<p>You’ll notice the use of <code>when</code> to conditionally include or exclude an effect. Any <code>nil</code> found in the <code>:fx</code> sequence will be ignored. </p>
<h2><a href="#dispatch" name="dispatch"></a><a name="dispatch"></a> :dispatch</h2>
<p><code>dispatch</code> one event. Expects a single vector.</p>
<p>usage:</p>
<pre><code class="clojure">{:fx [[:dispatch [:event-id "param1" :param2]]] }
</code></pre>
<p>Dispatch multiple events:</p>
<pre><code class="clojure">{:fx [[:dispatch [:event1 "param1" :param2]]
      [:dispatch [:second]]}
</code></pre>
<h2><a href="#dispatch-later" name="dispatch-later"></a><a name="dispatch-later"></a> :dispatch-later</h2>
<p><code>dispatch</code> one or more events after a given delay. Expects a payload which is a map with two keys <code>:ms</code> (milliseconds) and <code>:dispatch</code> (the event).</p>
<p>usage:</p>
<pre><code class="clj">{:db  new-db 
 :fx  [[:dispatch-later [{:ms 200 :dispatch [:event-id "param"]}]]]}  ;; dispatch in 200ms
</code></pre>
<p>Multiple with <code>:fx</code> introduced in re-frame v1.1.0:</p>
<pre><code class="clojure">{:fx [[:dispatch-later [{:ms 200 :dispatch [:event-id "param"]}]]
      [:dispatch-later [{:ms 100 :dispatch [:event-id "param"]}]]]}
</code></pre>
<p>Or deprecated variation prior to re-frame v1.1.0</p>
<pre><code class="clojure">{:dispatch-later [{:ms 200 :dispatch [:event-id "param"]}
                  {:ms 100 :dispatch [:event-id "param"]}]}
</code></pre>
<h2><a href="#deregister-event-handler" name="deregister-event-handler"></a><a name="deregister-event-handler"></a> :deregister-event-handler</h2>
<p>Removes a previously registered event handler. Expects the id of the event handler. </p>
<p>usage:</p>
<pre><code class="clojure">{:db new-db
 :fx [[:deregister-event-handler :my-id]])}
</code></pre>
<h2><a href="#dispatch-n-deprecated-" name="dispatch-n-deprecated-"></a><a name="dispatch-n"></a> :dispatch-n (Deprecated)</h2>
<p>This effect is deprecated in favour of using <code>:fx</code> with multiple <code>:dispatch</code> tuples.</p>
<p><code>dispatch</code> more than one events. Expects a seq of event vectors (typically a list of them). </p>
<p>usage:</p>
<pre><code class="clojure">{:db new-db
 :fx [[:dispatch-n (list [:do :all] [:three :of] [:these])]]}
</code></pre>
<p>Notes:</p>
<ol>
  <li>The events will be dispatched in the order provided. And, because events are handled FIFO, the events will subsequently be processed in the order provided.</li>
  <li>nils in the event collection are ignored which means events can be added conditionally:
    <p><code>clojure
 {:db new-db
  :fx [[:dispatch-n (list (when (&gt; 3 5) [:conditioned-out])
                       [:another-one])]]}
</code></p>
  </li>
</ol></div></div></div><script src="scripts/hashchange.js"></script></body></html>