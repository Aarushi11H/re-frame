<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Builtin Effects</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" type="text/css" href="styles/codox-re-frame.css" /></head><body><div></div><div class="sidebar primary"><div></div><div></div><div></div><ul><li class="depth-1 "><a href="api-intro.html"><div class="inner"><span>Overview</span></div></a></li><li class="depth-1  current"><a href="api-builtin-effects.html"><div class="inner"><span>Builtin Effects</span></div></a></li></ul><div></div><ul><li class="depth-1 "><a href="re-frame.core.html"><div class="inner"><span>re-frame.core</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><div class="sidebar secondary" style="width: 218px; left: 161px;">
    <h3 class="current">
        <a href="api-builtin-effects.html#top">
            <span class="inner">Builtin Effects</span>
        </a>
    </h3>
    <ul>
        <li class="depth-1">
            <a href="api-builtin-effects.html#db">
                <div class="inner">
                    <span>:db</span>
                </div>
            </a>
        </li>    
        <li class="depth-1">
            <a href="api-builtin-effects.html#fx">
                <div class="inner">
                    <span>:fx</span>
                </div>
            </a>
        </li>
        <li class="depth-1">
            <a href="api-builtin-effects.html#dispatch">
                <div class="inner">
                    <span>:dispatch</span>
                </div>
            </a>
        </li>
        <li class="depth-1">
            <a href="api-builtin-effects.html#dispatch-later">
                <div class="inner">
                    <span>:dispatch-later</span>
                </div>
            </a>
        </li>
        <li class="depth-1">
            <a href="api-builtin-effects.html#deregister-event-handler">
                <div class="inner">
                    <span>:deregister-event-handler</span>
                </div>
            </a>
        </li>
        <li class="depth-1">
            <a href="api-builtin-effects.html#dispatch-n">
                <div class="inner">
                    <span>:dispatch-n</span>
                </div>
            </a>
        </li>                            
    </ul>
</div>
<h1><a href="#builtin-effects" name="builtin-effects"></a>Builtin Effects</h1>
<p>In addition to the API provided in <code>re-frame.core</code>, re-frame supplies a small number of built-in effects which also contribute to the API.</p>
<h2><a href="#ordering" name="ordering"></a>Ordering</h2>
<p>An event handler (registered via <code>reg-event-fx</code>) can return a map containing many effects. But maps have no inherent ordering. So, in what order will re-frame action effets?</p>
<p>For example, an event handler might return:</p>
<pre><code class="clj ">{:dispatch [:some-id]
 :http     {:method :GET  :url "http://somewhere.com/"}
 :db       new-db}
</code></pre>
<p>Will the <code>:dispatch</code> effect be actioned before <code>:http</code>, and what about <code>:db</code>?</p>
<p><strong><em>Prior to v1.1.0</em></strong>, the answer is: no guarantees were provided about ordering. Actual order is an implementation detail upon which you should not rely.</p>
<p><strong><em>From v1.1.0 onwards</em></strong>, two things changed:</p>
<ul>
  <li>re-frame guaranteed that the <code>:db</code> effect will always be actioned first, if present. But other than that, no guarantee is given for the other effects.</li>
  <li>a new effect called <code>:fx</code> was added, and it provides a way for effects to be ordered.</li>
</ul>
<p>In fact, with v1.1.0 <strong><em>best practice changed</em></strong> to event handlers should only return two effects <code>:db</code> and <code>:fx</code>, in which case <code>:db</code> was always done first and then <code>:fx</code>, and within <code>:fx</code> the ordering is sequential. This new approach is more about making it easier to compose event handlers from many smaller functions, but more specificity around ordering was a consequence. </p>
<p>The new approach:</p>
<pre><code class="clj">{:db new-db 
 :fx [...]    ;; &lt;-- optional, contains one effect after another
</code></pre>
<p>Note: the latest, new method is backward compatible. All your existing code will continue to work (with <code>:db</code> always getting done first now).</p>
<h2><a href="#db" name="db"></a><a name="db"></a> :db</h2>
<p><code>reset!</code> <code>app-db</code> to be a new value. </p>
<p>The associated <code>value</code> is expected to be a map. This is always executed first before any other effect.</p>
<p>usage:</p>
<pre><code class="clojure">{:db  {:key1 value1 key2 value2}}   
</code></pre>
<p>Normal usage would look like this: </p>
<pre><code class="clojure">(reg-event-fx
  : token 
  (fn [{:keys [db]} event]
    {:db  (assoc db :some-key some-val)}))     ;; &lt;-- new value computed
</code></pre>
<blockquote>
  <p>Note: when present, a <code>:db</code> effect will be actioned before other sibling effects. But prior to v1.1.0 this was not the case.</p>
</blockquote>
<h2><a href="#fx" name="fx"></a><a name="fx"></a> :fx</h2>
<p>An effect which actions other effects, sequentially. </p>
<p>Expects a value which is a sequence, typically a vector. Each element in the sequence represents one effect. Each element is a 2-tuple of (1) an effect id and (2) the payload of the effect (the value given to the registered effect handler as an argument). </p>
<p>For example:</p>
<pre><code class="clj">{:db  new-db 
 :fx  [[:dispatch   [:some-id]]
       [:http-xhrio {:method :GET  :url "http://somewhere.com/"}]
       (when (&gt; 2 3) [:some-effect-id  some-payload])]}
</code></pre>
<p>Youâ€™ll notice the use of <code>when</code> to conditionally include or exclude an effect. Any <code>nil</code> found in the <code>:fx</code> sequence will be ignored. </p>
<h2><a href="#dispatch" name="dispatch"></a><a name="dispatch"></a> :dispatch</h2>
<p><code>dispatch</code> one event. Expects a single vector.</p>
<p>usage:</p>
<pre><code class="clojure">{:fx [[:dispatch [:event-id "param1" :param2]]] }
</code></pre>
<h2><a href="#dispatch-later" name="dispatch-later"></a><a name="dispatch-later"></a> :dispatch-later</h2>
<p><code>dispatch</code> one or more events after a given delay. Expects a payload which is a map with two keys <code>:ms</code> (milliseconds) and <code>:dispatch</code> (the event).</p>
<p>usage:</p>
<pre><code class="clj">{:db  new-db 
 :fx  [[:dispatch-later {:ms 200 :dispatch [:event-id "param"]}]]}  ;; dispatch in 200ms
</code></pre>
<h2><a href="#deregister-event-handler" name="deregister-event-handler"></a><a name="deregister-event-handler"></a> :deregister-event-handler</h2>
<p>Removes a previously registered event handler. Expects either a single id (typically a keyword), or a seq of ids.</p>
<p>usage:</p>
<pre><code class="clojure">{:db new-db
 :fx [[:deregister-event-handler :my-id]])}
</code></pre>
<p>or:</p>
<pre><code class="clojure">{:db new-db
 :fx [[:deregister-event-handler [:one-id :another-id]]]}
</code></pre>
<h2><a href="#dispatch-n-deprecated-" name="dispatch-n-deprecated-"></a><a name="dispatch-n"></a> :dispatch-n (Deprecated)</h2>
<p>Deprecated in favour of using <code>:fx</code> with multiple <code>:dispatch</code> tuples.</p>
<p><code>dispatch</code> more than one events. Expects a seq of event vectors (typically a list of them). </p>
<p>usage:</p>
<pre><code class="clojure">{:db new-db
 :fx [[:dispatch-n (list [:do :all] [:three :of] [:these])]]}
</code></pre>
<p>Notes:</p>
<ol>
  <li>The events will be dispatched in the order provided. And, because events are handled FIFO, the events will subsequently be processed in the order provided.</li>
  <li>nils in the event collection are ignored which means events can be added conditionally:
    <p><code>clojure
 {:db new-db
  :fx [[:dispatch-n (list (when (&gt; 3 5) [:conditioned-out])
                       [:another-one])]]}
</code></p>
  </li>
</ol></div></div></div><script src="scripts/hashchange.js"></script></body></html>