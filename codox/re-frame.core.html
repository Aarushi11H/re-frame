<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>re-frame.core documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" type="text/css" href="styles/codox-re-frame.css" /></head><body><div></div><div class="sidebar primary"><div></div><div></div><div></div><ul><li class="depth-1 "><a href="api-intro.html"><div class="inner"><span>Overview</span></div></a></li><li class="depth-1 "><a href="api-builtin-effects.html"><div class="inner"><span>Builtin Effects</span></div></a></li></ul><div></div><ul><li class="depth-1 current"><a href="re-frame.core.html"><div class="inner"><span>re-frame.core</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="re-frame.core.html#var--.3Einterceptor"><div class="inner"><span>-&gt;interceptor</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-add-post-event-callback"><div class="inner"><span>add-post-event-callback</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-after"><div class="inner"><span>after</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-assoc-coeffect"><div class="inner"><span>assoc-coeffect</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-assoc-effect"><div class="inner"><span>assoc-effect</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-clear-cofx"><div class="inner"><span>clear-cofx</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-clear-event"><div class="inner"><span>clear-event</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-clear-fx"><div class="inner"><span>clear-fx</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-clear-global-interceptor"><div class="inner"><span>clear-global-interceptor</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-clear-sub"><div class="inner"><span>clear-sub</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-clear-subscription-cache.21"><div class="inner"><span>clear-subscription-cache!</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-console"><div class="inner"><span>console</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-debug"><div class="inner"><span>debug</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-dispatch"><div class="inner"><span>dispatch</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-dispatch-sync"><div class="inner"><span>dispatch-sync</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-enqueue"><div class="inner"><span>enqueue</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-enrich"><div class="inner"><span>enrich</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-get-coeffect"><div class="inner"><span>get-coeffect</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-get-effect"><div class="inner"><span>get-effect</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-inject-cofx"><div class="inner"><span>inject-cofx</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-make-restore-fn"><div class="inner"><span>make-restore-fn</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-on-changes"><div class="inner"><span>on-changes</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-path"><div class="inner"><span>path</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-purge-event-queue"><div class="inner"><span>purge-event-queue</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-reg-cofx"><div class="inner"><span>reg-cofx</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-reg-event-ctx"><div class="inner"><span>reg-event-ctx</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-reg-event-db"><div class="inner"><span>reg-event-db</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-reg-event-fx"><div class="inner"><span>reg-event-fx</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-reg-fx"><div class="inner"><span>reg-fx</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-reg-global-interceptor"><div class="inner"><span>reg-global-interceptor</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-reg-sub"><div class="inner"><span>reg-sub</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-reg-sub-raw"><div class="inner"><span>reg-sub-raw</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-register-handler"><div class="inner"><span>register-handler</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-register-sub"><div class="inner"><span>register-sub</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-remove-post-event-callback"><div class="inner"><span>remove-post-event-callback</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-set-loggers.21"><div class="inner"><span>set-loggers!</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-subscribe"><div class="inner"><span>subscribe</span></div></a></li><li class="depth-1"><a href="re-frame.core.html#var-trim-v"><div class="inner"><span>trim-v</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">re-frame.core</h1><div class="doc"><div class="markdown"></div></div><div class="public anchor" id="var--.3Einterceptor"><h3>-&gt;interceptor</h3><div class="usage"><code>(-&gt;interceptor &amp; {:as m, :keys [id before after]})</code></div><div class="doc"><div class="markdown"><p>A utility function for creating interceptors.</p>
<p>Accepts three optional, named arguments:</p>
<ul>
  <li><code>:id</code> - an id for the interceptor (decorative only)</li>
  <li><code>:before</code> - the interceptor’s before function</li>
  <li><code>:after</code> - the interceptor’s after function</li>
</ul>
<p>Example use:</p>
<pre><code>(def my-interceptor
  (-&gt;interceptor
   :id     :my-interceptor
   :before (fn [context]            ;; you normally want to change :coeffects
             ... in here use get-coeffect  and assoc-coeffect)
   :after  (fn [context]                         ;; you normally want to change :effects
             (let [db (get-effect context :db)]  ;; (get-in context [:effects :db])
               (assoc-effect context :http-ajax {...}])))))
</code></pre></div></div></div><div class="public anchor" id="var-add-post-event-callback"><h3>add-post-event-callback</h3><div class="usage"><code>(add-post-event-callback f)</code><code>(add-post-event-callback id f)</code></div><div class="doc"><div class="markdown"><p>Registers a function <code>f</code> to be called after each event is processed. </p>
<p><code>f</code> will be called with two arguments:</p>
<ul>
  <li><code>event</code>: a vector. The event just processed.</li>
  <li><code>queue</code>: a PersistentQueue, possibly empty, of events yet to be processed.</li>
</ul>
<p>This facility is useful in advanced cases like:</p>
<ul>
  <li>you are implementing a complex bootstrap pipeline</li>
  <li>you want to create your own handling infrastructure, with perhaps multiple  handlers for the one event, etc. Hook in here.</li>
  <li>libraries providing ‘isomorphic javascript’ rendering on Nodejs or Nashorn.</li>
</ul>
<p><code>id</code> is typically a keyword. If it supplied when an <code>f</code> is added, it can be subsequently be used to identify it for removal. See <code>remove-post-event-callback</code>.</p></div></div></div><div class="public anchor" id="var-after"><h3>after</h3><div class="usage"><code>(after f)</code></div><div class="doc"><div class="markdown"><p>Returns an interceptor which runs the given function <code>f</code> in the <code>:after</code> position, presumably for side effects.</p>
<p><code>f</code> is called with two arguments: the <code>:effects</code> value for <code>:db</code> (or the <code>:coeffect</code> value of <code>:db</code> if no <code>:db</code> effect is returned) and the event. Its return value is ignored, so <code>f</code> can only side-effect.</p>
<p>An example of use can be seen in the re-frame github repo in <code>/examples/todomvc/events.cljs</code>:</p>
<ul>
  <li><code>f</code> runs schema validation (reporting any errors found).</li>
  <li><code>f</code> writes to localstorage.</li>
</ul></div></div></div><div class="public anchor" id="var-assoc-coeffect"><h3>assoc-coeffect</h3><div class="usage"><code>(assoc-coeffect context key value)</code></div><div class="doc"><div class="markdown"><p>A utility function, typically used when writing an interceptor’s <code>:before</code> function.</p>
<p>Adds or updates a key/value pair in the <code>:coeffects</code> map within <code>context</code>. </p></div></div></div><div class="public anchor" id="var-assoc-effect"><h3>assoc-effect</h3><div class="usage"><code>(assoc-effect context key value)</code></div><div class="doc"><div class="markdown"><p>A utility function, typically used when writing an interceptor’s <code>:after</code> function.</p>
<p>Adds or updates a key/value pair in the <code>:effects</code> map within <code>context</code>. </p></div></div></div><div class="public anchor" id="var-clear-cofx"><h3>clear-cofx</h3><div class="usage"><code>(clear-cofx)</code><code>(clear-cofx id)</code></div><div class="doc"><div class="markdown"><p>When called with no args, unregisters all coeffect handlers. When given one arg, assumed to be the <code>id</code> of a registered coeffect handler, unregisters the associated handler.</p></div></div></div><div class="public anchor" id="var-clear-event"><h3>clear-event</h3><div class="usage"><code>(clear-event)</code><code>(clear-event id)</code></div><div class="doc"><div class="markdown"><p>When called with no args, unregisters all event handlers. When given one arg, assumed to be the <code>id</code> of a registered event handler, unregisters the associated handler.</p></div></div></div><div class="public anchor" id="var-clear-fx"><h3>clear-fx</h3><div class="usage"><code>(clear-fx)</code><code>(clear-fx id)</code></div><div class="doc"><div class="markdown"><p>When called with no args, unregisters all effect handlers. </p>
<p>When given one arg, assumed to be the <code>id</code> of a registered effect handler, unregisters the associated handler.</p></div></div></div><div class="public anchor" id="var-clear-global-interceptor"><h3>clear-global-interceptor</h3><div class="usage"><code>(clear-global-interceptor)</code><code>(clear-global-interceptor id)</code></div><div class="doc"><div class="markdown"><p>Unregisters (removes) global interceptors.</p>
<p>When called with no arguments, it unregisters all global interceptors. </p>
<p>When given one argument, assumed to be the <code>id</code> of a currently registered global interceptor, it removes the associated interceptor.</p></div></div></div><div class="public anchor" id="var-clear-sub"><h3>clear-sub</h3><div class="usage"><code>(clear-sub)</code><code>(clear-sub query-id)</code></div><div class="doc"><div class="markdown"><p>When called with no args, unregisters all subscription handlers.</p>
<p>When given one arg, assumed to be a <code>query-id</code> of a registered subscription handler, unregisters the associated handler.</p>
<p>NOTE: Depending on the usecase it may also be necessary to call  <code>clear-subscription-cache!</code>.</p></div></div></div><div class="public anchor" id="var-clear-subscription-cache.21"><h3>clear-subscription-cache!</h3><div class="usage"><code>(clear-subscription-cache!)</code></div><div class="doc"><div class="markdown"><p>Removes all subscriptions from the cache.</p>
<p>For use at development time or test time. Useful when hot realoding reloading to subscription handler code or after a React/render exception, because React components won’t have been cleaned up properly. And this, in turn, means the subscriptions within those components won’t have been cleaned up correctly. So this forces the issue.</p></div></div></div><div class="public anchor" id="var-console"><h3>console</h3><div class="usage"><code>(console level &amp; args)</code></div><div class="doc"><div class="markdown"><p>A utility logging function to be used by libraries which extend re-frame, like perhaps an effect handler.</p>
<p>It will write the given <code>args</code> to js/console at the given log <code>level</code>.</p>
<p><code>level</code> can be one of <code>:log</code> <code>:error</code> <code>:warn</code> <code>:debug</code> <code>:group</code> <code>:groupEnd</code>.</p>
<p>Example usage:</p>
<pre><code>(console :error "Oh, dear God, it happened:" a-var "and" another)
(console :warn "Possible breach of containment wall at:" dt)
</code></pre></div></div></div><div class="public anchor" id="var-debug"><h3>debug</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>An interceptor which logs/instruments an event handler’s actions to <code>js/console.debug</code>. See examples/todomvc/src/events.cljs for use.</p>
<p>Output includes:</p>
<ol>
  <li>the event vector</li>
  <li>a <code>clojure.data/diff</code> of db, before vs after, which shows  the changes caused by the event handler. To understand the output,  you should understand:  <a href="https://clojuredocs.org/clojure.data/diff" target="_blank"></a><a href="https://clojuredocs.org/clojure.data/diff">https://clojuredocs.org/clojure.data/diff</a>.</li>
</ol>
<p>You’d typically include this interceptor after (to the right of) any <code>path</code> interceptor.</p>
<p>Warning: calling <code>clojure.data/diff</code> on large, complex data structures can be slow. So, you won’t want this interceptor present in production code. So condition it out like this :</p>
<pre><code>(re-frame.core/reg-event-db
  :evt-id
  [(when ^boolean goog.DEBUG re-frame.core/debug)]  ;; &lt;-- conditional
  (fn [db v]
     ...))
</code></pre>
<p>To make this code fragment work, you’ll also have to set <code>goog.DEBUG</code> to <code>false</code> in your production builds. For an example, look in <code>project.clj</code> of /examples/todomvc.</p></div></div></div><div class="public anchor" id="var-dispatch"><h3>dispatch</h3><div class="usage"><code>(dispatch event)</code></div><div class="doc"><div class="markdown"><p>Queue <code>event</code> for processing (handling). </p>
<p><code>event</code> is a vector and the first element is typically a keyword which identifies the kind of event.</p>
<p>The event will be added to a FIFO processing queue, so event handling does not happen immediately. It will happen ‘very soon’ bit not now. And if the queue already contains events, they will be processed first.</p>
<p>Usage:</p>
<pre><code>(dispatch [:order "pizza" {:supreme 2 :meatlovers 1 :veg 1}])
</code></pre></div></div></div><div class="public anchor" id="var-dispatch-sync"><h3>dispatch-sync</h3><div class="usage"><code>(dispatch-sync event)</code></div><div class="doc"><div class="markdown"><p>Synchronously (immediately) process <code>event</code>. It does <strong>not</strong> queue the event for handling later as <code>dispatch</code> does.</p>
<p><code>event</code>is a vector and the first element is typically a keyword which identifies the kind of event.</p>
<p>Generally, avoid using this function, and instead, use <code>dispatch</code>. It is an error to use <code>dispatch-sync</code> within an event handler because you can’t immediately process an new event when one is already part way through being processed.</p>
<p>Can be useful in a narrow set of cases where any delay in processing is a problem:</p>
<ol>
  <li>the <code>:on-change</code> handler of a text field where we are expecting fast typing</li>
  <li>when initialising your app - see ‘main’ in examples/todomvc/src/core.cljs</li>
  <li>in a unit test where immediate, synchronous processing is useful</li>
</ol>
<p>Usage:</p>
<pre><code>(dispatch-sync [:sing :falsetto "piano accordion"])
</code></pre></div></div></div><div class="public anchor" id="var-enqueue"><h3>enqueue</h3><div class="usage"><code>(enqueue context interceptors)</code></div><div class="doc"><div class="markdown"><p>A utility function, used when writing an interceptor’s <code>:before</code> function.</p>
<p>Adds the given collection of <code>interceptors</code> to those already in <code>context's</code> execution <code>:queue</code>. It returns the updated <code>context</code>.</p>
<p>So, it provides a way for one Interceptor to add more interceptors to the currently executing interceptor chain.</p></div></div></div><div class="public anchor" id="var-enrich"><h3>enrich</h3><div class="usage"><code>(enrich f)</code></div><div class="doc"><div class="markdown"><p>Returns an Interceptor which will run the given function <code>f</code> in the <code>:after</code> position. </p>
<p><code>f</code> is called with two arguments: <code>db</code> and <code>v</code>, and is expected to return a modified <code>db</code>.</p>
<p>Unlike the <code>after</code> interceptor which is only about side effects, <code>enrich</code> expects <code>f</code> to process and alter the given <code>db</code> coeffect in some useful way, contributing to the derived data, flowing vibe.</p>
<h4><a href="#example-use-" name="example-use-"></a>Example Use:</h4>
<p>Imagine that todomvc needed to do duplicate detection - if any two todos had the same text, then highlight their background, and report them via a warning at the bottom of the panel.</p>
<p>Almost any user action (edit text, add new todo, remove a todo) requires a complete reassessment of duplication errors and warnings. Eg: that edit just made might have introduced a new duplicate, or removed one. Same with any todo removal. So we need to re-calculate warnings after any CRUD events associated with the todos list.</p>
<p>Unless we are careful, we might end up coding subtly different checks for each kind of CRUD operation. The duplicates check made after ‘delete todo’ event might be subtly different to that done after an editing operation. Nice and efficient, but fiddly. A bug generator approach.</p>
<p>So, instead, we create an <code>f</code> which recalculates ALL warnings from scratch every time there is ANY change. It will inspect all the todos, and reset ALL FLAGS every time (overwriting what was there previously) and fully recalculate the list of duplicates (displayed at the bottom?).</p>
<a href="https://twitter.com/nathanmarz/status/879722740776939520" target="_blank">https://twitter.com/nathanmarz/status/879722740776939520</a>
<p>By applying <code>f</code> in an <code>:enrich</code> interceptor, after every CRUD event, we keep the handlers simple and yet we ensure this important step (of getting warnings right) is not missed on any change.</p>
<p>We can test <code>f</code> easily - it is a pure function - independently of any CRUD operation.</p>
<p>This brings huge simplicity at the expense of some re-computation each time. This may be a very satisfactory trade-off in many cases.</p></div></div></div><div class="public anchor" id="var-get-coeffect"><h3>get-coeffect</h3><div class="usage"><code>(get-coeffect context)</code><code>(get-coeffect context key)</code><code>(get-coeffect context key not-found)</code></div><div class="doc"><div class="markdown"><p>A utility function, typically used when writing an interceptor’s <code>:before</code> function.</p>
<p>When called with one argument, it returns the <code>:coeffects</code> map from with that <code>context</code>.</p>
<p>When called with two or three arguments, behaves like <code>clojure.core/get</code> and returns the value mapped to <code>key</code> in the <code>:coeffects</code> map within <code>context</code>, <code>not-found</code> or <code>nil</code> if <code>key</code> is not present.</p></div></div></div><div class="public anchor" id="var-get-effect"><h3>get-effect</h3><div class="usage"><code>(get-effect context)</code><code>(get-effect context key)</code><code>(get-effect context key not-found)</code></div><div class="doc"><div class="markdown"><p>A utility function, used when writing interceptors, typically within an <code>:after</code> function.</p>
<p>When called with one argument, returns the <code>:effects</code> map from the <code>context</code>.</p>
<p>When called with two or three arguments, behaves like <code>clojure.core/get</code> and returns the value mapped to <code>key</code> in the effects map, <code>not-found</code> or <code>nil</code> if <code>key</code> is not present.</p></div></div></div><div class="public anchor" id="var-inject-cofx"><h3>inject-cofx</h3><div class="usage"><code>(inject-cofx id)</code><code>(inject-cofx id value)</code></div><div class="doc"><div class="markdown"><p>Given an <code>id</code>, and an optional, arbitrary <code>value</code>, returns an interceptor whose <code>:before</code> adds to the <code>:coeffects</code> (map) by calling a pre-registered ‘coeffect handler’ identified by the <code>id</code>.</p>
<p>The previous association of a <code>coeffect handler</code> with an <code>id</code> will have happened via a call to <code>re-frame.core/reg-cofx</code> - generally on program startup.</p>
<p>Within the created interceptor, this ‘looked up’ <code>coeffect handler</code> will be called (within the <code>:before</code>) with two arguments:</p>
<ul>
  <li>the current value of <code>:coeffects</code></li>
  <li>optionally, the originally supplied arbitrary <code>value</code></li>
</ul>
<p>This <code>coeffect handler</code> is expected to modify and return its first, <code>coeffects</code> argument.</p>
<h5><a href="#example-of-and-working-together" name="example-of-and-working-together"></a>Example of <code>inject-cofx</code> and <code>reg-cofx</code> working together</h5>
<p>First - Early in app startup, you register a <code>coeffect handler</code> for <code>:datetime</code>:</p>
<pre><code>(re-frame.core/reg-cofx
  :datetime                        ;; usage  (inject-cofx :datetime)
  (fn coeffect-handler
    [coeffect]
    (assoc coeffect :now (js/Date.))))   ;; modify and return first arg
</code></pre>
<p>Second - Later, add an interceptor to an -fx event handler, using <code>inject-cofx</code>:</p>
<pre><code>(re-frame.core/reg-event-fx            ;; when registering an event handler
  :event-id
  [ ... (inject-cofx :datetime) ... ]  ;; &lt;-- create an injecting interceptor
  (fn event-handler
    [coeffect event]
      ;;... in here can access (:now coeffect) to obtain current datetime ... 
    )))
</code></pre>
<h5><a href="#background" name="background"></a>Background</h5>
<p><code>coeffects</code> are the input resources required by an event handler to perform its job. The two most obvious ones are <code>db</code> and <code>event</code>. But sometimes an event handler might need other resources.</p>
<p>Perhaps an event handler needs a random number or a GUID or the current datetime. Perhaps it needs access to a DataScript database connection.</p>
<p>If an event handler directly accesses these resources, it stops being pure and, consequently, it becomes harder to test, etc. So we don’t want that.</p>
<p>Instead, the interceptor created by this function is a way to ‘inject’ ‘necessary resources’ into the <code>:coeffects</code> (map) subsequently given to the event handler at call time.</p></div></div></div><div class="public anchor" id="var-make-restore-fn"><h3>make-restore-fn</h3><div class="usage"><code>(make-restore-fn)</code></div><div class="doc"><div class="markdown"><p>This is a utility function, typically used in testing.</p>
<p>It checkpoints the current state of re-frame and returns a function which, when later called, will restore re-frame to the checkpointed state.</p>
<p>The checkpoint includes <code>app-db</code>, all registered handlers and all subscriptions.</p></div></div></div><div class="public anchor" id="var-on-changes"><h3>on-changes</h3><div class="usage"><code>(on-changes f out-path &amp; in-paths)</code></div><div class="doc"><div class="markdown"><p>Returns an interceptor which will observe N paths within <code>db</code>, and if any of them test not identical? to their previous value (as a result of a event handler being run), then it will run <code>f</code> to compute a new value, which is then assoc-ed into the given <code>out-path</code> within <code>db</code>.</p>
<p>Example Usage:</p>
<pre><code>(defn my-f
  [a-val b-val]
  ... some computation on a and b in here)

;; use it
(def my-interceptor (on-changes my-f [:c] [:a] [:b]))

(reg-event-db
  :event-id
  [... my-interceptor ...]  ;; &lt;-- ultimately used here
  (fn [db v]
     ...))
</code></pre>
<p>If you put this Interceptor on handlers which might change paths <code>:a</code> or <code>:b</code>, it will:</p>
<ul>
  <li>call <code>f</code> each time the value at path <code>[:a]</code> or <code>[:b]</code> changes</li>
  <li>call <code>f</code> with the values extracted from <code>[:a]</code> <code>[:b]</code></li>
  <li>assoc the return value from <code>f</code> into the path <code>[:c]</code></li>
</ul></div></div></div><div class="public anchor" id="var-path"><h3>path</h3><div class="usage"><code>(path &amp; args)</code></div><div class="doc"><div class="markdown"><p>Returns an interceptor which acts somewhat like <code>clojure.core/update-in</code>, in the sense that the event handler is given a specific part of <code>app-db</code> to change, not all of <code>app-db</code>. </p>
<p>The interceptor has both a <code>:before</code> and <code>:after</code> functions. The <code>:before</code> replaces<br />the <code>:db</code> key within coeffects with a sub-path within <code>app-db</code>. The <code>:after</code> reverses the process, and it grafts the handler’s return value back into db, at the right path.</p>
<p>Examples:</p>
<pre><code>(path :some :path)
(path [:some :path])
(path [:some :path] :to :here)
(path [:some :path] [:to] :here)
</code></pre>
<p>Example Use:</p>
<pre><code>(reg-event-db
  :event-id
  (path [:a :b])  ;; &lt;-- used here, in interceptor chain
  (fn [b v]       ;; 1st arg is not db. Is the value from path [:a :b] within db
    ... new-b))   ;; returns a new value for that path (not the entire db)
</code></pre>
<p>Notes:</p>
<ol>
  <li><code>path</code> may appear more than once in an interceptor chain. Progressive narrowing.</li>
  <li>if <code>:effects</code> contains no <code>:db</code> effect, can’t graft a value back in.</li>
</ol></div></div></div><div class="public anchor" id="var-purge-event-queue"><h3>purge-event-queue</h3><div class="usage"><code>(purge-event-queue)</code></div><div class="doc"><div class="markdown"><p>Removes all events currently queued for processing</p></div></div></div><div class="public anchor" id="var-reg-cofx"><h3>reg-cofx</h3><div class="usage"><code>(reg-cofx id handler)</code></div><div class="doc"><div class="markdown"><p>Register the given coeffect <code>handler</code> for the given <code>id</code>, for later use within <code>inject-cofx</code>:</p>
<ul>
  <li><code>id</code> is keyword, often namespaced.</li>
  <li><code>handler</code> is a function which takes either one or two arguements, the first of which is  always <code>coeffects</code> and which returns an updated <code>coeffects</code>.</li>
</ul>
<p>See the docs for <code>inject-cofx</code> for example use.</p></div></div></div><div class="public anchor" id="var-reg-event-ctx"><h3>reg-event-ctx</h3><div class="usage"><code>(reg-event-ctx id handler)</code><code>(reg-event-ctx id interceptors handler)</code></div><div class="doc"><div class="markdown"><p>Register the given event <code>handler</code> (function) for the given <code>id</code>. Optionally, provide an <code>interceptors</code> chain:</p>
<ul>
  <li><code>id</code> is typically a namespaced keyword (but can be anything)</li>
  <li><code>handler</code> is a function: (context-map event-vector) -&gt; context-map</li>
</ul>
<p>This form of registration is almost never used.</p></div></div></div><div class="public anchor" id="var-reg-event-db"><h3>reg-event-db</h3><div class="usage"><code>(reg-event-db id handler)</code><code>(reg-event-db id interceptors handler)</code></div><div class="doc"><div class="markdown"><p>Register the given event <code>handler</code> (function) for the given <code>id</code>. Optionally, provide an <code>interceptors</code> chain:</p>
<ul>
  <li><code>id</code> is typically a namespaced keyword (but can be anything)</li>
  <li><code>handler</code> is a function: (db event) -&gt; db</li>
  <li><code>interceptors</code> is a collection of interceptors. Will be flattened and nils removed.</li>
</ul>
<p>Note: <code>handler</code> is wrapped in its own interceptor and added to the end of the interceptor chain, so that, in the end, only a chain is registered.</p></div></div></div><div class="public anchor" id="var-reg-event-fx"><h3>reg-event-fx</h3><div class="usage"><code>(reg-event-fx id handler)</code><code>(reg-event-fx id interceptors handler)</code></div><div class="doc"><div class="markdown"><p>Register the given event <code>handler</code> (function) for the given <code>id</code>. Optionally, provide an <code>interceptors</code> chain:</p>
<ul>
  <li><code>id</code> is typically a namespaced keyword (but can be anything)</li>
  <li><code>handler</code> is a function: (coeffects-map event-vector) -&gt; effects-map</li>
  <li><code>interceptors</code> is a collection of interceptors. Will be flattened and nils removed.</li>
</ul>
<p>Note: <code>handler</code> is wrapped in its own interceptor and added to the end of the interceptor chain, so that, in the end, only a chain is registered.</p></div></div></div><div class="public anchor" id="var-reg-fx"><h3>reg-fx</h3><div class="usage"><code>(reg-fx id handler)</code></div><div class="doc"><div class="markdown"><p>Register the given effect <code>handler</code> for the given <code>id</code>:</p>
<ul>
  <li><code>id</code> is keyword, often namespaced.</li>
  <li><code>handler</code> is a side-effecting function which takes a single argument and whose return  value is ignored.</li>
</ul>
<p>To use, first, associate <code>:effect2</code> with a handler.</p>
<p>(reg-fx  :effect2  (fn [value]  … do something side-effect-y))</p>
<p>Then, later, if an event handler were to return this effects map …</p>
<p>{:effect2 [1 2]}</p>
<p>then the <code>handler</code> <code>fn</code> we registered previously, using <code>reg-fx</code>, will be called with an argument of <code>[1 2]</code>.</p></div></div></div><div class="public anchor" id="var-reg-global-interceptor"><h3>reg-global-interceptor</h3><div class="usage"><code>(reg-global-interceptor interceptor)</code></div><div class="doc"><div class="markdown"><p>Registers the given <code>interceptor</code> as a global interceptor. Global interceptors are included in the processing chain of every event.</p>
<p>When you register an event handler, you have the option of supplying an interceptor chain. Any global interceptors you register are effectively prepending to this chain.</p>
<p>Global interceptors are run in the order that they are registered.</p></div></div></div><div class="public anchor" id="var-reg-sub"><h3>reg-sub</h3><div class="usage"><code>(reg-sub query-id &amp; args)</code></div><div class="doc"><div class="markdown"><p>A call to <code>reg-sub</code> associates two functions with a <code>query-id</code>. </p>
<p>These two functions combine to provide the ‘mechanism’ for creating a node in the Signal Graph, for the specified <code>query-id</code>. </p>
<p>The three arguments are: </p>
<ul>
  <li><code>query-id</code> - typically a namespaced keyword (later used in subscribe)</li>
  <li>optionally, an <code>input signals</code> function which returns the input data  flows required by this kind of node.</li>
  <li>a <code>computation function</code> which computes the value of the node (from the input data flows)</li>
</ul>
<p>Later, during app execution, a call to <code>(subscribe [:sub-id 3 :blue])</code>, will trigger the need for a new Signal Graph node (for the query <code>[:sub-id 3 :blue]</code>). And that means creating a new <code>:sub-id</code> node. To do that the two functions associated with <code>:sub-id</code> are looked up and used.</p>
<p>Just to repeat: calling <code>reg-sub</code> does not immediately create a node. It only registers ‘the mechanism’ (the two functions) by which nodes can be created later, when a node is bought into existence by the use of <code>subscribe</code> in a <code>View Function</code>.</p>
<p>The <code>computation function</code> is expected to take two arguments:</p>
<ul>
  <li><code>input-values</code> - the values which flow into this node</li>
  <li><code>query-vector</code> - the vector given to <code>subscribe</code></li>
</ul>
<p>and it returns a computed value (which then becomes the output of the node)</p>
<p>When <code>computation function</code> is called, the 2nd <code>query-vector</code> argument will be that vector supplied to the <code>subscribe</code>. So, if the call was <code>(subscribe [:sub-id 3 :blue])</code>, then the <code>query-vector</code> supplied to the computaton function will be <code>[:sub-id 3 :blue]</code>.</p>
<p>The argument(s) supplied between <code>query-id</code> and the <code>computation-function</code> can vary in 3 ways, but whatever is there defines the <code>input signals</code> part of <code>the mechanism</code>, specifying what input values “flow into” the <code>computation function</code> (as the 1st argument) when it is called.</p>
<p><code>reg-sub</code> can be called in one of three ways, because there are three ways to define the input signals part. But note, the 2nd method, in which a <code>signals function</code> is explicitly supplied, is the most canonical and instructive. The other two are really just sugary variations.</p>
<p>First variation - no input signal function given:</p>
<pre><code>(reg-sub
  :query-id
  a-computation-fn)   ;; has signature:  (fn [db query-vec]  ... ret-value)
</code></pre>
<p>In the absence of an explicit <code>signals function</code>, the node’s input signal defaults to <code>app-db</code>  and, as a result, the value within <code>app-db</code> (a map) is  is given as the 1st argument when <code>a-computation-fn</code> is called.</p>
<p>Second variation - a signal function is explicitly supplied:</p>
<pre><code>(reg-sub
  :query-id
  signal-fn     ;; &lt;-- here
  computation-fn)
</code></pre>
<p>This is the most canonical and instructive of the three variations.</p>
<p>When a node is created from the template, the <code>signal function</code> will be called and it is expected to return the input signal(s) as either a singleton, if there is only one, or a sequence if there are many, or a map with the signals as the values.</p>
<p>The current values of the returned signals will be supplied as the 1st argument to the <code>a-computation-fn</code> when it is called - and subject to what this <code>signal-fn</code> returns, this value will be either a singleton, sequence or map of them (paralleling the structure returned by the <code>signal function</code>).</p>
<p>This example <code>signal function</code> returns a 2-vector of input signals.</p>
<pre><code>(fn [query-vec dynamic-vec]
   [(subscribe [:a-sub])
    (subscribe [:b-sub])])
</code></pre>
<p>The associated computation function must be written to expect a 2-vector of values for its first argument:</p>
<pre><code>(fn [[a b] query-vec]     ;; 1st argument is a seq of two values
  ....)
</code></pre>
<p>If, on the other hand, the signal function was simpler and returned a singleton, like this:</p>
<p>(fn [query-vec dynamic-vec]  (subscribe [:a-sub])) ;; &lt;– returning a singleton</p>
<p>then the associated computation function must be written to expect a single value as the 1st argument:</p>
<pre><code>(fn [a query-vec]       ;; 1st argument is a single value
   ...)
</code></pre>
<p>Further Note: variation #1 above, in which an <code>input-fn</code> was not supplied, like this:</p>
<pre><code>(reg-sub
  :query-id
  a-computation-fn)   ;; has signature:  (fn [db query-vec]  ... ret-value)
</code></pre>
<p>is the equivalent of using this 2nd variation and explicitly suppling a <code>signal-fn</code> which returns <code>app-db</code>:</p>
<pre><code>(reg-sub
  :query-id
  (fn [_ _]  re-frame/app-db)   ;; &lt;--- explicit signal-fn
  a-computation-fn)             ;; has signature:  (fn [db query-vec]  ... ret-value)
</code></pre>
<p>Third variation - syntax Sugar</p>
<pre><code>(reg-sub
  :a-b-sub
  :&lt;- [:a-sub]
  :&lt;- [:b-sub]
  (fn [[a b] query-vec]    ;; 1st argument is a seq of two values
    {:a a :b b}))
</code></pre>
<p>This 3rd variation is just syntactic sugar for the 2nd. Instead of providing an <code>signals-fn</code> you provide one or more pairs of <code>:&lt;-</code> and a subscription vector.</p>
<p>If you supply only one pair a singleton will be supplied to the computation function, as if you had supplied a <code>signal-fn</code> returning only a single value:</p>
<pre><code>(reg-sub
  :a-sub
  :&lt;- [:a-sub]
  (fn [a query-vec]      ;; only one pair, so 1st argument is a single value
    ...))
</code></pre>
<p>For further understanding, read the tutorials, and look at the detailed comments in /examples/todomvc/src/subs.cljs</p></div></div></div><div class="public anchor" id="var-reg-sub-raw"><h3>reg-sub-raw</h3><div class="usage"><code>(reg-sub-raw query-id handler-fn)</code></div><div class="doc"><div class="markdown"><p>This is a low level, advanced function. You should probably be using <code>reg-sub</code> instead.</p>
<p>Some docs are available in <a href="http://day8.github.io/re-frame/flow-mechanics/" target="_blank"></a><a href="http://day8.github.io/re-frame/flow-mechanics/">http://day8.github.io/re-frame/flow-mechanics/</a></p></div></div></div><div class="public anchor" id="var-register-handler"><h3>register-handler</h3><h4 class="deprecated">deprecated in 0.8.0</h4><div class="usage"><code>(register-handler &amp; args)</code></div><div class="doc"><div class="markdown"><p>Deprecated. Use <code>reg-event-db</code> instead.</p></div></div></div><div class="public anchor" id="var-register-sub"><h3>register-sub</h3><h4 class="deprecated">deprecated in 0.8.0</h4><div class="usage"><code>(register-sub &amp; args)</code></div><div class="doc"><div class="markdown"><p>Deprecated. Use <code>reg-sub-raw</code> instead.</p></div></div></div><div class="public anchor" id="var-remove-post-event-callback"><h3>remove-post-event-callback</h3><div class="usage"><code>(remove-post-event-callback id)</code></div><div class="doc"><div class="markdown"><p>Unregisters a post event callback function, identified by <code>id</code>. </p>
<p>Such a function must have been previously registered via <code>add-post-event-callback</code></p></div></div></div><div class="public anchor" id="var-set-loggers.21"><h3>set-loggers!</h3><div class="usage"><code>(set-loggers! new-loggers)</code></div><div class="doc"><div class="markdown"><p>Internally, re-frame outputs warnings, errors etc via logging functions: <code>warn</code>, <code>log</code>, <code>error</code>, <code>group</code> and <code>groupEnd</code></p>
<p>By default, these functions map directly to their default <code>js/console</code> implementations, but you can override that with your own functions (set or subset). </p>
<p><code>new-loggers</code> should be a map containing a subset of they keys for the standard <code>loggers</code>.</p>
<p>Example Usage:</p>
<pre><code>(defn my-logger      ;; here is my alternative logging function
  [&amp; args]
  (post-it-somewhere (apply str args)))

;; now install my alternative loggers
(re-frame.core/set-loggers!  {:warn my-logger :log my-logger})
</code></pre></div></div></div><div class="public anchor" id="var-subscribe"><h3>subscribe</h3><div class="usage"><code>(subscribe query)</code><code>(subscribe query dynv)</code></div><div class="doc"><div class="markdown"><p>Given a <code>query</code> vector, returns a Reagent <code>reaction</code> which will, over time, reactively deliver a stream of values. So in FRP-ish terms, it returns a <code>Signal</code>.</p>
<p>To obtain the returned Signal/Stream’s current value, it must be <code>deref</code>ed.</p>
<p><code>query</code> is a vector of at least one element. The first element is the <code>query-id</code>, typically a namespaced keyword. The rest of the vector’s elements are optional, additional values which parameterise the query performed.</p>
<p><code>dynv</code> is an optional 3rd argument, which is a vector of further input signals (atoms, reactions, etc), NOT values. This argument exists for historical reasons and is borderline deprecated these days.</p>
<h4><a href="#example-usage-" name="example-usage-"></a>Example Usage:</h4>
<pre><code>(subscribe [:items])
(subscribe [:items "blue" :small])
(subscribe [:items {:colour "blue"  :size :small}])
</code></pre>
<p>Note: for any given call to <code>subscribe</code> there must have been a previous call to <code>reg-sub</code>, registering the query handler (functions) associated with <code>query-id</code>.</p>
<h4><a href="#hint" name="hint"></a>Hint</h4>
<p>When used in a view function BE SURE to <code>deref</code> the returned value. In fact, to avoid any mistakes, some prefer to define:</p>
<pre><code>(def &lt;sub  (comp deref re-frame.core/subscribe))
</code></pre>
<p>And then, within their views, they call <code>(&lt;sub [:items :small])</code> rather than using <code>subscribe</code> directly.</p>
<h4><a href="#de-duplication" name="de-duplication"></a>De-duplication</h4>
<p>Two, or more, concurrent subscriptions for the same query will source reactive updates from the one executing handler.</p></div></div></div><div class="public anchor" id="var-trim-v"><h3>trim-v</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>An interceptor which removes the first element of the event vector, before it is supplied to the event handler, allowing you to write more  aesthetically pleasing event handlers. No leading underscore on the event-v!</p>
<p>Your event handlers will look like this:</p>
<pre><code>(reg-event-db
  :event-id
  [... trim-v ...]    ;; &lt;-- added to the interceptors
  (fn [db [x y z]]    ;; &lt;-- instead of [_ x y z]
    ...)
</code></pre></div></div></div></div></body></html>